extern crate getopts;

use deadpool_postgres::{Pool, Manager};
use pombase::bio::gocam_model_process::read_gocam_models_from_dir;
use pombase::bio::pdb_reader::read_pdb_data;
use pombase::bio::util::parse_orcid_name_map;
use pombase::db::ChadoQueries;
use pombase::uniprot::parse_uniprot;

use std::collections::HashMap;
use std::str::FromStr;

use std::error::Error;
use std::env;
use std::process;

use getopts::Options;

use flexstr::shared_fmt as flex_fmt;

extern crate pombase;

use pombase::db::Raw;
use pombase::web::config::*;
use pombase::web::data_build::*;
use pombase::interpro::parse_interpro;

use pombase::gene_history::parse_gene_history;

const PKG_NAME: &str = env!("CARGO_PKG_NAME");
const VERSION: &str = env!("CARGO_PKG_VERSION");

fn print_usage(program: &str, opts: Options) {
    let brief = format!("Usage: {} [options]", program);
    print!("{}", opts.usage(&brief));
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    println!("{} v{}", PKG_NAME, VERSION);

    let args: Vec<String> = env::args().collect();
    let mut opts = Options::new();

    opts.optflag("h", "help", "print this help message");
    opts.optopt("c", "config-file", "Configuration file name", "CONFIG");
    opts.optopt("C", "doc-config-file",
                "Documentation configuration file name", "DOC_CONFIG");
    opts.optopt("p", "postgresql-connection-string",
                "PostgresSQL connection string like: postgres://user:pass@host/db_name",
                "CONN_STR");
    opts.optopt("i", "domain-data-file",
                "The name of the InterPro data file generated by 'pombase-domain-process'",
                "FILE");
    opts.optopt("", "uniprot-data-file",
                "The name of the UniProt data file",
                "FILE");
    opts.optopt("", "filter-uniprot-references",
                "A comma separated list of PMIDs of data to ignore from the UniProt file", "PMIDs");
    opts.optopt("r", "rnacentral-data-file",
                "The name of the Rfam data file generated by 'pombase-rnacentral-process'",
                "FILE");
    opts.optopt("", "pdb-data-file",
                "The name of the PBD data file generated by 'process_pdbe_data_file.py'",
                "FILE");
    opts.optopt("", "go-eco-mapping",
                "GO evidence code to ECO ID mapping from http://purl.obolibrary.org/obo/eco/gaf-eco-mapping.txt", "FILE");
    opts.optopt("", "gene-history-file",
                "The gene history file in this format: https://github.com/pombase/genome_changelog/blob/master/results/all_coordinate_changes_file_comments_no_type_change.tsv", "FILE");
    opts.optopt("", "orcid-name-map",
                "A TSV file mapping ORCIDs to names", "FILE");
    opts.optopt("", "gocam-model-directory",
                "The directory containing the GO-CAM model JSON files", "DIR");
    opts.optopt("d", "output-directory",
                "Destination directory for the output", "DIR");

    let matches = match opts.parse(&args[1..]) {
        Ok(m) => m,
        Err(f) => panic!("Invalid options\n{}", f)
    };

    let program = args[0].clone();

    if matches.opt_present("help") {
        print_usage(&program, opts);
        process::exit(0);
    }

    if !matches.opt_present("config-file") {
        println!("no -c|--config-file option");
        print_usage(&program, opts);
        process::exit(1);
    }
    if !matches.opt_present("doc-config-file") {
        println!("no --doc-config-file option");
        print_usage(&program, opts);
        process::exit(1);
    }
    if !matches.opt_present("postgresql-connection-string") {
        println!("no -p|--postgresql-connection-string option");
        print_usage(&program, opts);
        process::exit(1);
    }
    if !matches.opt_present("go-eco-mapping") {
        println!("no --go-eco-mapping option");
        print_usage(&program, opts);
        process::exit(1);
    }
    if !matches.opt_present("domain-data-file") {
        println!("no -i|--domain-data-file option");
        print_usage(&program, opts);
        process::exit(1);
    }
    if !matches.opt_present("output-directory") {
        println!("no -d|--output-directory option");
        print_usage(&program, opts);
        process::exit(1);
    }

    let config = Config::read(&matches.opt_str("c").unwrap());
    let doc_config = DocConfig::read(&matches.opt_str("C").unwrap());
    let connection_string = matches.opt_str("p").unwrap();
    let maybe_uniprot_file = matches.opt_str("uniprot-data-file");
    let filter_uniprot_references: Vec<_> =
        matches.opt_str("filter-uniprot-references")
        .unwrap_or_default()
        .trim()
        .split(",")
        .map(|s| flex_fmt!("PMID:{}", s.trim_start_matches("PMID:")))
        .collect();

    let interpro_json = matches.opt_str("i").unwrap();
    let maybe_rnacentral_json = matches.opt_str("r");
    let maybe_pdb_data_file_name = matches.opt_str("pdb-data-file");
    let go_eco_mapping = GoEcoMapping::read(&matches.opt_str("go-eco-mapping").unwrap())?;
    let gene_history_filename = matches.opt_str("gene-history-file");
    let gene_history =
        if let Some(gene_history_filename) = gene_history_filename {
           Some(parse_gene_history(&gene_history_filename))
        } else {
           None
        };
    let orcid_name_map_filename = matches.opt_str("orcid-name-map");
    let gocam_model_dir = matches.opt_str("gocam-model-directory");

    let gocam_models =
        if let Some(model_dir) = gocam_model_dir {
            read_gocam_models_from_dir(&model_dir)?
        } else {
            vec![]
        };

    let output_dir = matches.opt_str("d").unwrap();

    let pg_config = tokio_postgres::Config::from_str(&connection_string)?;

    let manager = Manager::new(pg_config, tokio_postgres::NoTls);

    let pool = Pool::builder(manager).max_size(16).build().unwrap();

    let mut client = pool.get().await?;

    let raw = Raw::new(&mut client).await?;

    let chado_queries = ChadoQueries::new(&config, &mut client).await?;

    let interpro_data = parse_interpro(&config, &interpro_json);

    let uniprot_data = maybe_uniprot_file
        .map(|filename| parse_uniprot(&filename, &filter_uniprot_references));
    let rnacentral_data =
        if let Some(rnacentral_json) = maybe_rnacentral_json {
            Some(pombase::rnacentral::parse_annotation_json(&rnacentral_json)?)
        } else {
            None
        };

    let (pdb_entry_map, pdb_ref_entry_map) =
        if let Some(ref pdb_data_file_name) = maybe_pdb_data_file_name {
            let (pdb_entry_map, pdb_ref_entry_map) = read_pdb_data(pdb_data_file_name);
            (Some(pdb_entry_map), Some(pdb_ref_entry_map))
        } else {
            (None, None)
        };

    let orcid_name_map = 
        if let Some(ref orcid_name_map_filename) = orcid_name_map_filename {
            parse_orcid_name_map(orcid_name_map_filename)?
        } else {
            HashMap::new()
        };

    let web_data_build = WebDataBuild::new(&raw, interpro_data,
                                           uniprot_data,
                                           rnacentral_data, gene_history,
                                           pdb_entry_map, pdb_ref_entry_map,
                                           chado_queries,
                                           orcid_name_map,
                                           gocam_models,
                                           &config);
    let web_data = web_data_build.get_web_data();

    match web_data.write(&config, &go_eco_mapping, &doc_config, &output_dir) {
        Ok(_) => (),
        Err(e) => {
            panic!("error while writing: {}", e);
        },
    }

    Ok(())
}
